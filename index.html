<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NIKKE 이름 감지 OCR</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 24px;
      background: #111;
      color: #eee;
    }
    button {
      padding: 10px 16px;
      font-size: 16px;
      cursor: pointer;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    .row { margin: 8px 0; }
    #status {
      margin-top: 8px;
      white-space: pre-line;
      color: #b8f;
    }
    #result {
      margin-top: 8px;
      font-size: 18px;
      color: #9ef;
      white-space: pre-line;
    }
    .wrap {
      margin-top: 16px;
      border: 1px solid #333;
      border-radius: 8px;
      overflow: hidden;
      display: inline-block;
      background: #000;
    }
    video {
      display: block;
      width: min(960px, 90vw);
      height: auto;
      background: #000;
    }
    .hint {
      margin-top: 8px;
      color: #aaa;
      font-size: 13px;
    }
    .debug {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .debug canvas {
      border: 1px solid #333;
      background: #000;
      image-rendering: pixelated;
    }
  </style>

  <!-- Tesseract.js (브라우저 OCR) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <h1>NIKKE 이름 OCR (화면공유 + ROI 프리셋)</h1>

  <div class="row">
    <button id="btnStart">화면 감지 시작</button>
    <button id="btnStop" disabled>중지</button>
    <button id="btnOnce" disabled>이름 1회 추출</button>
  </div>

  <div id="status">대기 중...</div>
  <div id="result">감지된 이름: (없음)</div>

  <div class="wrap">
    <video id="preview" autoplay playsinline muted></video>
  </div>

  <div class="hint">
    ※ 공유 창에서 <b>창(Window)</b> 선택 권장<br />
    ※ OCR은 전체화면이 아니라 <b>이름 ROI만</b> 검사해서 성능을 아낍니다.
  </div>

  <!-- 디버그용 캔버스 -->
  <div class="debug">
    <div>
      <div style="font-size:12px;color:#aaa">원본 ROI</div>
      <canvas id="roiCanvas" width="200" height="80"></canvas>
    </div>
    <div>
      <div style="font-size:12px;color:#aaa">OCR 전처리 ROI</div>
      <canvas id="ocrCanvas" width="300" height="120"></canvas>
    </div>
  </div>

  <script>
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnOnce = document.getElementById("btnOnce");
    const statusEl = document.getElementById("status");
    const resultEl = document.getElementById("result");
    const videoEl = document.getElementById("preview");
    const roiCanvas = document.getElementById("roiCanvas");
    const ocrCanvas = document.getElementById("ocrCanvas");

    let captureStream = null;
    let ocrWorker = null;
    let ocrReady = false;
    let ocrBusy = false;
    let ocrLoopTimer = null;
    let detectedName = "";

    // 필요하면 이름 후보 목록(JSON) 로드해서 OCR 결과 보정 가능
    // 예: /data/names.json => ["앨리스","홍련","라푼젤", ...]
    let knownNames = [];

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function setResult(text) {
      resultEl.textContent = `감지된 이름: ${text || "(없음)"}`;
    }

    // -----------------------------
    // 1) 화면비율별 이름 OCR ROI 프리셋 (정규화 좌표)
    // 네가 올린 7장 기준으로 측정한 값
    // -----------------------------
    const NAME_ROI_PRESETS = {
      // 가로 4:3 (윈도우)
      landscape_4_3:   { x: 0.875, y: 0.235, w: 0.081, h: 0.043 },

      // 가로 16:9 (윈도우)
      landscape_16_9:  { x: 0.901, y: 0.235, w: 0.065, h: 0.043 },

      // 가로 21:9 (윈도우)
      landscape_21_9:  { x: 0.919, y: 0.240, w: 0.055, h: 0.045 },

      // 세로 4:3 (윈도우)
      portrait_4_3:    { x: 0.792, y: 0.240, w: 0.135, h: 0.045 },

      // 세로 16:9 (윈도우)
      portrait_16_9:   { x: 0.729, y: 0.240, w: 0.176, h: 0.045 },

      // 세로 21:9 (윈도우, 매우 좁음)
      portrait_21_9:   { x: 0.734, y: 0.304, w: 0.164, h: 0.034 },

      // 전체화면 16:9
      fullscreen_16_9: { x: 0.902, y: 0.208, w: 0.065, h: 0.047 },
    };

    // ROI 여유 패딩 (현재 프리셋에 추가로 조금 넓힘)
    const ROI_PAD_SCALE = {
      x: 0.12,  // 좌우 12%
      y: 0.20   // 상하 20%
    };

    function classifyLayout(videoWidth, videoHeight) {
      const a = videoWidth / videoHeight;

      // 네 샘플 기준으로 분류 범위 설정
      if (a >= 2.05) return "landscape_21_9";
      if (a >= 1.75) return "fullscreen_16_9"; // 전체화면 16:9
      if (a >= 1.55) return "landscape_16_9";
      if (a >= 1.10) return "landscape_4_3";

      // 세로 모드
      if (a >= 0.63) return "portrait_4_3";
      if (a >= 0.48) return "portrait_16_9";
      return "portrait_21_9";
    }

    function inflateNormRect(rect, scaleX = 0.1, scaleY = 0.1) {
      const padX = rect.w * scaleX;
      const padY = rect.h * scaleY;
      return clampNormRect({
        x: rect.x - padX,
        y: rect.y - padY,
        w: rect.w + padX * 2,
        h: rect.h + padY * 2
      });
    }

    function clampNormRect(r) {
      let x = Math.max(0, r.x);
      let y = Math.max(0, r.y);
      let w = Math.max(0.001, r.w);
      let h = Math.max(0.001, r.h);
      if (x + w > 1) w = 1 - x;
      if (y + h > 1) h = 1 - y;
      return { x, y, w, h };
    }

    function normToPxRect(normRect, frameW, frameH) {
      const x = Math.round(normRect.x * frameW);
      const y = Math.round(normRect.y * frameH);
      const w = Math.round(normRect.w * frameW);
      const h = Math.round(normRect.h * frameH);
      return { x, y, w, h };
    }

    function getActiveNameRoi(videoWidth, videoHeight) {
      const mode = classifyLayout(videoWidth, videoHeight);
      const base = NAME_ROI_PRESETS[mode] || NAME_ROI_PRESETS.landscape_16_9;
      const roi = inflateNormRect(base, ROI_PAD_SCALE.x, ROI_PAD_SCALE.y);
      return { mode, roi };
    }

    // -----------------------------
    // 2) 캔버스 유틸: video -> ROI 캡처
    // -----------------------------
    function captureRoiFromVideo(video, roiPx, outCanvas) {
      const ctx = outCanvas.getContext("2d", { willReadFrequently: true });
      outCanvas.width = roiPx.w;
      outCanvas.height = roiPx.h;
      ctx.drawImage(
        video,
        roiPx.x, roiPx.y, roiPx.w, roiPx.h,
        0, 0, roiPx.w, roiPx.h
      );
    }

    // -----------------------------
    // 3) OCR 전처리
    // - 확대
    // - grayscale
    // - threshold (흰 글자/검은 배경 -> 검은 글자/흰 배경으로 반전)
    // -----------------------------
    function preprocessNameRoi(srcCanvas, dstCanvas) {
      const scale = 3; // OCR 정확도 향상용 업스케일
      dstCanvas.width = srcCanvas.width * scale;
      dstCanvas.height = srcCanvas.height * scale;

      const dctx = dstCanvas.getContext("2d", { willReadFrequently: true });
      dctx.imageSmoothingEnabled = false;
      dctx.drawImage(srcCanvas, 0, 0, dstCanvas.width, dstCanvas.height);

      const img = dctx.getImageData(0, 0, dstCanvas.width, dstCanvas.height);
      const data = img.data;

      // 간단한 grayscale + contrast + threshold + invert
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        // luminance
        let y = 0.299 * r + 0.587 * g + 0.114 * b;

        // contrast boost (검은 배경/흰 글자 대비 강화)
        y = (y - 128) * 1.8 + 128;
        if (y < 0) y = 0;
        if (y > 255) y = 255;

        // threshold
        // 이름 글자는 흰색, 배경은 검정이므로 -> 반전해서 "검정 글자 / 흰 배경" 형태로 만듦
        const v = (y > 145) ? 0 : 255;

        data[i] = v;
        data[i + 1] = v;
        data[i + 2] = v;
        data[i + 3] = 255;
      }

      dctx.putImageData(img, 0, 0);
    }

    // -----------------------------
    // 4) OCR 초기화
    // -----------------------------
    async function initOcrWorker() {
      if (ocrReady) return;
      setStatus("OCR 엔진 초기화 중... (처음 1회는 조금 걸릴 수 있음)");

      // tesseract.js 버전에 따라 createWorker 시그니처가 조금 다를 수 있음
      // CDN v5 기준 동작 형태
      ocrWorker = await Tesseract.createWorker("kor+eng", 1, {
        logger: (m) => {
          // 필요 시 로깅
          // console.log("OCR", m);
        }
      });

      // PSM 8 = single word (버전별 상수 접근이 다를 수 있어 숫자로 지정)
      await ocrWorker.setParameters({
        tessedit_pageseg_mode: "8",
        preserve_interword_spaces: "0",
      });

      ocrReady = true;
      setStatus("OCR 엔진 준비 완료 ✅");
    }

    // -----------------------------
    // 5) OCR 결과 후처리 (문자열 정리)
    // -----------------------------
    function cleanOcrName(raw) {
      if (!raw) return "";

      let s = String(raw)
        .replace(/\s+/g, "")
        .replace(/[|]/g, "I")
        .replace(/[“”"']/g, "")
        .trim();

      // 한글/영문/숫자만 남김 (NIKKE 이름 중 일부는 영숫자 포함 가능)
      s = s.replace(/[^0-9A-Za-z가-힣]/g, "");

      if (!s) return "";

      // 혹시 OCR이 여러 덩어리를 붙여 읽었을 때 대비:
      // 가장 "이름스러워 보이는" 긴 토큰 선택
      const parts = s.match(/[0-9A-Za-z가-힣]+/g) || [];
      if (!parts.length) return s;

      // 우선 가장 긴 토큰
      parts.sort((a, b) => b.length - a.length);
      return parts[0];
    }

    // 선택사항: 이름 사전 보정 (OCR 오타 교정)
    function levenshtein(a, b) {
      const m = a.length, n = b.length;
      const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }
      return dp[m][n];
    }

    function correctByKnownNames(candidate) {
      if (!candidate || !knownNames.length) return candidate;

      let best = candidate;
      let bestScore = Infinity;

      for (const name of knownNames) {
        const d = levenshtein(candidate, name);
        // 길이 차이가 너무 큰 건 빠르게 제외
        const lenDiff = Math.abs(candidate.length - name.length);
        const score = d + lenDiff * 0.3;
        if (score < bestScore) {
          bestScore = score;
          best = name;
        }
      }

      // 너무 차이가 크면 원본 유지
      // (이 값은 이름 리스트 품질에 따라 조절)
      if (bestScore > Math.max(2, candidate.length * 0.6)) {
        return candidate;
      }
      return best;
    }

    async function loadKnownNames() {
      try {
        const res = await fetch("./data/names.json", { cache: "no-store" });
        if (!res.ok) return;
        const arr = await res.json();
        if (Array.isArray(arr)) {
          knownNames = arr.filter(Boolean).map(String);
          console.log("knownNames loaded:", knownNames.length);
        }
      } catch (e) {
        // 파일 없으면 그냥 무시
        console.log("names.json not loaded (optional)", e);
      }
    }

    // -----------------------------
    // 6) 현재 프레임에서 이름 추출
    // -----------------------------
    async function extractNameOnce() {
      if (!captureStream || !videoEl.srcObject) return null;
      if (!ocrReady) await initOcrWorker();
      if (ocrBusy) return null;
      if (!videoEl.videoWidth || !videoEl.videoHeight) return null;

      ocrBusy = true;
      try {
        const frameW = videoEl.videoWidth;
        const frameH = videoEl.videoHeight;

        const { mode, roi: roiNorm } = getActiveNameRoi(frameW, frameH);
        const roiPx = normToPxRect(roiNorm, frameW, frameH);

        // 원본 ROI 캡처
        captureRoiFromVideo(videoEl, roiPx, roiCanvas);

        // OCR 전처리
        preprocessNameRoi(roiCanvas, ocrCanvas);

        // OCR 실행
        const ret = await ocrWorker.recognize(ocrCanvas);
        const rawText = ret?.data?.text ?? "";
        let name = cleanOcrName(rawText);

        // 선택: 이름 사전으로 보정
        if (name) {
          name = correctByKnownNames(name);
        }

        detectedName = name || "";
        setResult(detectedName);

        setStatus([
          "이름 OCR 완료 ✅",
          `레이아웃 분류: ${mode}`,
          `프레임 크기: ${frameW} x ${frameH}`,
          `ROI(px): x=${roiPx.x}, y=${roiPx.y}, w=${roiPx.w}, h=${roiPx.h}`,
          `OCR 원문: ${JSON.stringify(rawText)}`,
          `정리 결과: ${detectedName || "(없음)"}`
        ].join("\n"));

        return detectedName;
      } catch (err) {
        console.error(err);
        setStatus("이름 OCR 실패: " + (err?.message || String(err)));
        return null;
      } finally {
        ocrBusy = false;
      }
    }

    function startOcrLoop() {
      stopOcrLoop();

      // 이름은 자주 변하지 않으므로 700~1200ms 권장
      ocrLoopTimer = setInterval(() => {
        if (!ocrBusy) extractNameOnce();
      }, 900);
    }

    function stopOcrLoop() {
      if (ocrLoopTimer) {
        clearInterval(ocrLoopTimer);
        ocrLoopTimer = null;
      }
    }

    // -----------------------------
    // 7) 화면공유 시작/중지
    // -----------------------------
    async function startScreenCapture() {
      try {
        stopScreenCapture(); // 기존 스트림 정리

        setStatus("화면 공유 권한 요청 중...\n공유 창에서 '창(Window)'를 선택해주세요.");

        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            frameRate: { ideal: 15, max: 30 }
          },
          audio: false
        });

        captureStream = stream;
        videoEl.srcObject = stream;

        await new Promise((resolve) => {
          if (videoEl.readyState >= 1) return resolve();
          videoEl.onloadedmetadata = () => resolve();
        });

        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings ? track.getSettings() : {};

        track.onended = () => {
          stopScreenCapture();
          setStatus("공유가 종료되었습니다.");
        };

        btnStart.disabled = true;
        btnStop.disabled = false;
        btnOnce.disabled = false;

        await loadKnownNames();   // optional
        await initOcrWorker();    // 첫 OCR 전에 미리 로드하면 체감 좋음
        startOcrLoop();

        setStatus([
          "화면 감지 준비 완료 ✅",
          `실제 영상 크기: ${videoEl.videoWidth} x ${videoEl.videoHeight}`,
          `displaySurface: ${settings.displaySurface || "알 수 없음"}`,
          "이름 OCR 루프 시작 (900ms 간격)"
        ].join("\n"));

      } catch (err) {
        console.error(err);

        if (err && err.name === "NotAllowedError") {
          setStatus("사용자가 화면 공유 권한을 취소했습니다.");
        } else if (err && err.name === "NotFoundError") {
          setStatus("공유 가능한 화면/창을 찾을 수 없습니다.");
        } else {
          setStatus("화면 공유 시작 실패: " + (err?.message || String(err)));
        }

        btnStart.disabled = false;
        btnStop.disabled = true;
        btnOnce.disabled = true;
      }
    }

    function stopScreenCapture() {
      stopOcrLoop();

      if (captureStream) {
        captureStream.getTracks().forEach((track) => track.stop());
        captureStream = null;
      }

      videoEl.srcObject = null;
      btnStart.disabled = false;
      btnStop.disabled = true;
      btnOnce.disabled = true;
      setStatus("중지됨.");
    }

    // 버튼 연결
    btnStart.addEventListener("click", startScreenCapture);
    btnStop.addEventListener("click", stopScreenCapture);
    btnOnce.addEventListener("click", () => extractNameOnce());

    // 전역 확인용 (원하면 콘솔에서 확인)
    window.getDetectedName = () => detectedName;
  </script>
</body>
</html>
